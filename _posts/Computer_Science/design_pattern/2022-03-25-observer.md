---
layout: post
title: observer
description: ''
date: '2022-03-25'
categories: design-pattern
note:
usemathjax:
mermaid: true
---

## Introduction

1. One to many relationship (one observerable to many observers)
2. The state of observerable changed and all observers are notified

## Why?

Some business logic needs to update data according to another objects' status; for example, weather Apps need to update data according to the weather data. The pattern to solve this kind of problem is observer.

## How?

Intuitively, we may just keep asking whether the weather changed and then update it accordingly. However, the results are always lagging. As a result, we implement this pattern to solve the problem, letting weather object to tell the weather Apps that the status changed.

<div class="mermaid">
graph LR
  id1((Observable)) -- push: I changed status --> id2((observers))
  id1((Observable)) -- push: I changed status --> id3((observers))
  id1((Observable)) -- push: I changed status --> ...
</div>

and the UML

了解 interface 跟 concrete 的差異

<div class="mermaid">
classDiagram
  Observable --> Observer : has many

  Observable : add(observer)
  Observable : remove(observer)
  Observable : notify()

  Observer : update()
</div>

## What?

```ruby

```

give an example

## Reference

[Observer Pattern – Design Patterns (ep 2)](https://www.youtube.com/watch?v=_BpmfnqjgzQ&list=PLrhzvIcii6GNjpARdnO4ueTUAVR9eMBpc&index=2)
